/* tslint:disable */
/* eslint-disable */
/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.1.0-SNAPSHOT
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ArtifactMetaData
 */
export interface ArtifactMetaData {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    createdBy: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    modifiedBy: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    modifiedOn: string;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof ArtifactMetaData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    version: string;
    /**
     * 
     * @type {ArtifactType}
     * @memberof ArtifactMetaData
     */
    type: ArtifactType;
    /**
     * 
     * @type {number}
     * @memberof ArtifactMetaData
     */
    globalId: number;
    /**
     * 
     * @type {ArtifactState}
     * @memberof ArtifactMetaData
     */
    state: ArtifactState;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArtifactMetaData
     */
    labels?: Array<string>;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof ArtifactMetaData
     */
    properties?: { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof ArtifactMetaData
     */
    groupId?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactMetaData
     */
    contentId: number;
}
/**
 * Describes the response received when searching for artifacts.
 * @export
 * @interface ArtifactSearchResults
 */
export interface ArtifactSearchResults {
    /**
     * The artifacts returned in the result set.
     * @type {Array<SearchedArtifact>}
     * @memberof ArtifactSearchResults
     */
    artifacts: Array<SearchedArtifact>;
    /**
     * The total number of artifacts that matched the query that produced the result set (may be  more than the number of artifacts in the result set).
     * @type {number}
     * @memberof ArtifactSearchResults
     */
    count: number;
}
/**
 * Describes the state of an artifact or artifact version.  The following states are possible:  * ENABLED * DISABLED * DEPRECATED 
 * @export
 * @enum {string}
 */

export enum ArtifactState {
    Enabled = 'ENABLED',
    Disabled = 'DISABLED',
    Deprecated = 'DEPRECATED'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ArtifactType {
    Avro = 'AVRO',
    Protobuf = 'PROTOBUF',
    Json = 'JSON',
    Openapi = 'OPENAPI',
    Asyncapi = 'ASYNCAPI',
    Graphql = 'GRAPHQL',
    Kconnect = 'KCONNECT',
    Wsdl = 'WSDL',
    Xsd = 'XSD',
    Xml = 'XML'
}

/**
 * 
 * @export
 * @interface EditableMetaData
 */
export interface EditableMetaData {
    /**
     * 
     * @type {string}
     * @memberof EditableMetaData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EditableMetaData
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditableMetaData
     */
    labels?: Array<string>;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof EditableMetaData
     */
    properties?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum IfExists {
    Fail = 'FAIL',
    Update = 'UPDATE',
    Return = 'RETURN',
    ReturnOrUpdate = 'RETURN_OR_UPDATE'
}

/**
 * 
 * @export
 * @interface LogConfiguration
 */
export interface LogConfiguration {
    /**
     * 
     * @type {LogLevel}
     * @memberof LogConfiguration
     */
    level: LogLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum LogLevel {
    Debug = 'DEBUG',
    Trace = 'TRACE',
    Warn = 'WARN',
    Error = 'ERROR',
    Severe = 'SEVERE',
    Warning = 'WARNING',
    Info = 'INFO',
    Config = 'CONFIG',
    Fine = 'FINE',
    Finer = 'FINER',
    Finest = 'FINEST'
}

/**
 * All error responses, whether `4xx` or `5xx` will include one of these as the response body.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The short error message.
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * The server-side error code.
     * @type {number}
     * @memberof ModelError
     */
    error_code?: number;
    /**
     * Full details about the error.  This might contain a server stack trace, for example.
     * @type {string}
     * @memberof ModelError
     */
    detail?: string;
    /**
     * The error name - typically the classname of the exception thrown by the server.
     * @type {string}
     * @memberof ModelError
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface NamedLogConfiguration
 */
export interface NamedLogConfiguration {
    /**
     * 
     * @type {string}
     * @memberof NamedLogConfiguration
     */
    name: string;
    /**
     * 
     * @type {LogLevel}
     * @memberof NamedLogConfiguration
     */
    level: LogLevel;
}
/**
 * 
 * @export
 * @interface NamedLogConfigurationAllOf
 */
export interface NamedLogConfigurationAllOf {
    /**
     * 
     * @type {string}
     * @memberof NamedLogConfigurationAllOf
     */
    name: string;
}
/**
 * The mapping between a user/principal and their role.
 * @export
 * @interface RoleMapping
 */
export interface RoleMapping {
    /**
     * 
     * @type {string}
     * @memberof RoleMapping
     */
    principalId: string;
    /**
     * 
     * @type {RoleType}
     * @memberof RoleMapping
     */
    role: RoleType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum RoleType {
    ReadOnly = 'READ_ONLY',
    Developer = 'DEVELOPER',
    Admin = 'ADMIN'
}

/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    config: string;
    /**
     * 
     * @type {RuleType}
     * @memberof Rule
     */
    type?: RuleType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum RuleType {
    Validity = 'VALIDITY',
    Compatibility = 'COMPATIBILITY'
}

/**
 * 
 * @export
 * @interface RuleViolationCause
 */
export interface RuleViolationCause {
    /**
     * 
     * @type {string}
     * @memberof RuleViolationCause
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleViolationCause
     */
    context?: string;
}
/**
 * All error responses, whether `4xx` or `5xx` will include one of these as the response body.
 * @export
 * @interface RuleViolationError
 */
export interface RuleViolationError {
    /**
     * List of rule violation causes.
     * @type {Array<RuleViolationCause>}
     * @memberof RuleViolationError
     */
    causes: Array<RuleViolationCause>;
    /**
     * The short error message.
     * @type {string}
     * @memberof RuleViolationError
     */
    message?: string;
    /**
     * The server-side error code.
     * @type {number}
     * @memberof RuleViolationError
     */
    error_code?: number;
    /**
     * Full details about the error.  This might contain a server stack trace, for example.
     * @type {string}
     * @memberof RuleViolationError
     */
    detail?: string;
    /**
     * The error name - typically the classname of the exception thrown by the server.
     * @type {string}
     * @memberof RuleViolationError
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface RuleViolationErrorAllOf
 */
export interface RuleViolationErrorAllOf {
    /**
     * List of rule violation causes.
     * @type {Array<RuleViolationCause>}
     * @memberof RuleViolationErrorAllOf
     */
    causes: Array<RuleViolationCause>;
}
/**
 * Models a single artifact from the result set returned when searching for artifacts.
 * @export
 * @interface SearchedArtifact
 */
export interface SearchedArtifact {
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof SearchedArtifact
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    createdBy: string;
    /**
     * 
     * @type {ArtifactType}
     * @memberof SearchedArtifact
     */
    type: ArtifactType;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchedArtifact
     */
    labels?: Array<string>;
    /**
     * 
     * @type {ArtifactState}
     * @memberof SearchedArtifact
     */
    state: ArtifactState;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    modifiedBy?: string;
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof SearchedArtifact
     */
    groupId?: string;
}
/**
 * Models a single artifact from the result set returned when searching for artifacts.
 * @export
 * @interface SearchedVersion
 */
export interface SearchedVersion {
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    createdBy: string;
    /**
     * 
     * @type {ArtifactType}
     * @memberof SearchedVersion
     */
    type: ArtifactType;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchedVersion
     */
    labels?: Array<string>;
    /**
     * 
     * @type {ArtifactState}
     * @memberof SearchedVersion
     */
    state: ArtifactState;
    /**
     * 
     * @type {number}
     * @memberof SearchedVersion
     */
    globalId: number;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    version: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof SearchedVersion
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof SearchedVersion
     */
    contentId: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SortBy {
    Name = 'name',
    CreatedOn = 'createdOn'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum SortOrder {
    Asc = 'asc',
    Desc = 'desc'
}

/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    builtOn?: string;
}
/**
 * 
 * @export
 * @interface UpdateRole
 */
export interface UpdateRole {
    /**
     * 
     * @type {RoleType}
     * @memberof UpdateRole
     */
    role: RoleType;
}
/**
 * 
 * @export
 * @interface UpdateState
 */
export interface UpdateState {
    /**
     * 
     * @type {ArtifactState}
     * @memberof UpdateState
     */
    state: ArtifactState;
}
/**
 * Information about a single user.
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    admin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    developer?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    viewer?: boolean;
}
/**
 * 
 * @export
 * @interface VersionMetaData
 */
export interface VersionMetaData {
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    createdBy: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    createdOn: string;
    /**
     * 
     * @type {ArtifactType}
     * @memberof VersionMetaData
     */
    type: ArtifactType;
    /**
     * 
     * @type {number}
     * @memberof VersionMetaData
     */
    globalId: number;
    /**
     * 
     * @type {ArtifactState}
     * @memberof VersionMetaData
     */
    state?: ArtifactState;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof VersionMetaData
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VersionMetaData
     */
    labels?: Array<string>;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof VersionMetaData
     */
    properties?: { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof VersionMetaData
     */
    groupId?: string;
    /**
     * 
     * @type {number}
     * @memberof VersionMetaData
     */
    contentId: number;
}
/**
 * Describes the response received when searching for artifacts.
 * @export
 * @interface VersionSearchResults
 */
export interface VersionSearchResults {
    /**
     * The total number of versions that matched the query (may be more than the number of versions returned in the result set).
     * @type {number}
     * @memberof VersionSearchResults
     */
    count: number;
    /**
     * The collection of artifact versions returned in the result set.
     * @type {Array<SearchedVersion>}
     * @memberof VersionSearchResults
     */
    versions: Array<SearchedVersion>;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule: async (rule: Rule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('createGlobalRule', 'rule', rule)
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMapping: async (roleMapping: RoleMapping, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleMapping' is not null or undefined
            assertParamExists('createRoleMapping', 'roleMapping', roleMapping)
            const localVarPath = `/admin/roleMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule: async (rule: RuleType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('deleteGlobalRule', 'rule', rule)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleMapping: async (principalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('deleteRoleMapping', 'principalId', principalId)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig: async (rule: RuleType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('getGlobalRuleConfig', 'rule', rule)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
         * @summary Get a single logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogConfiguration: async (logger: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'logger' is not null or undefined
            assertParamExists('getLogConfiguration', 'logger', logger)
            const localVarPath = `/admin/loggers/{logger}`
                .replace(`{${"logger"}}`, encodeURIComponent(String(logger)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMapping: async (principalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('getRoleMapping', 'principalId', principalId)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {any} body The ZIP file representing the previously exported registry data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importData: async (body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('importData', 'body', body)
            const localVarPath = `/admin/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/zip';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the configured logging levels.  These override the default logging configuration.
         * @summary List logging configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogConfigurations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/loggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleMappings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/roleMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the configured logger configuration (if any) for the given logger.
         * @summary Removes logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLogConfiguration: async (logger: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'logger' is not null or undefined
            assertParamExists('removeLogConfiguration', 'logger', logger)
            const localVarPath = `/admin/loggers/{logger}`
                .replace(`{${"logger"}}`, encodeURIComponent(String(logger)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configures the logger referenced by the provided logger name with the given configuration.
         * @summary Set a logger\'s configuration
         * @param {string} logger The name of a single logger.
         * @param {LogConfiguration} logConfiguration The new logger configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogConfiguration: async (logger: string, logConfiguration: LogConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'logger' is not null or undefined
            assertParamExists('setLogConfiguration', 'logger', logger)
            // verify required parameter 'logConfiguration' is not null or undefined
            assertParamExists('setLogConfiguration', 'logConfiguration', logConfiguration)
            const localVarPath = `/admin/loggers/{logger}`
                .replace(`{${"logger"}}`, encodeURIComponent(String(logger)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig: async (rule: RuleType, rule2: Rule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'rule', rule)
            // verify required parameter 'rule2' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'rule2', rule2)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleMapping: async (principalId: string, updateRole: UpdateRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('updateRoleMapping', 'principalId', principalId)
            // verify required parameter 'updateRole' is not null or undefined
            assertParamExists('updateRoleMapping', 'updateRole', updateRole)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGlobalRule(rule: Rule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGlobalRule(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleMapping(roleMapping: RoleMapping, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleMapping(roleMapping, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllGlobalRules(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllGlobalRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGlobalRule(rule: RuleType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGlobalRule(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleMapping(principalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleMapping(principalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalRuleConfig(rule: RuleType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalRuleConfig(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
         * @summary Get a single logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogConfiguration(logger: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamedLogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogConfiguration(logger, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleMapping(principalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleMapping(principalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {any} body The ZIP file representing the previously exported registry data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importData(body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importData(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGlobalRules(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGlobalRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the configured logging levels.  These override the default logging configuration.
         * @summary List logging configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogConfigurations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NamedLogConfiguration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleMappings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleMappings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the configured logger configuration (if any) for the given logger.
         * @summary Removes logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeLogConfiguration(logger: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamedLogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeLogConfiguration(logger, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configures the logger referenced by the provided logger name with the given configuration.
         * @summary Set a logger\'s configuration
         * @param {string} logger The name of a single logger.
         * @param {LogConfiguration} logConfiguration The new logger configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLogConfiguration(logger: string, logConfiguration: LogConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamedLogConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLogConfiguration(logger, logConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalRuleConfig(rule, rule2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleMapping(principalId, updateRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule(rule: Rule, options?: any): AxiosPromise<void> {
            return localVarFp.createGlobalRule(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMapping(roleMapping: RoleMapping, options?: any): AxiosPromise<void> {
            return localVarFp.createRoleMapping(roleMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules(options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule(rule: RuleType, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGlobalRule(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleMapping(principalId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleMapping(principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportData(options?: any): AxiosPromise<any> {
            return localVarFp.exportData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig(rule: RuleType, options?: any): AxiosPromise<Rule> {
            return localVarFp.getGlobalRuleConfig(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
         * @summary Get a single logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogConfiguration(logger: string, options?: any): AxiosPromise<NamedLogConfiguration> {
            return localVarFp.getLogConfiguration(logger, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMapping(principalId: string, options?: any): AxiosPromise<RoleMapping> {
            return localVarFp.getRoleMapping(principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {any} body The ZIP file representing the previously exported registry data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importData(body: any, options?: any): AxiosPromise<void> {
            return localVarFp.importData(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules(options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the configured logging levels.  These override the default logging configuration.
         * @summary List logging configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogConfigurations(options?: any): AxiosPromise<Array<NamedLogConfiguration>> {
            return localVarFp.listLogConfigurations(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleMappings(options?: any): AxiosPromise<Array<RoleMapping>> {
            return localVarFp.listRoleMappings(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the configured logger configuration (if any) for the given logger.
         * @summary Removes logger configuration
         * @param {string} logger The name of a single logger.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLogConfiguration(logger: string, options?: any): AxiosPromise<NamedLogConfiguration> {
            return localVarFp.removeLogConfiguration(logger, options).then((request) => request(axios, basePath));
        },
        /**
         * Configures the logger referenced by the provided logger name with the given configuration.
         * @summary Set a logger\'s configuration
         * @param {string} logger The name of a single logger.
         * @param {LogConfiguration} logConfiguration The new logger configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogConfiguration(logger: string, logConfiguration: LogConfiguration, options?: any): AxiosPromise<NamedLogConfiguration> {
            return localVarFp.setLogConfiguration(logger, logConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateGlobalRuleConfig(rule, rule2, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: any): AxiosPromise<void> {
            return localVarFp.updateRoleMapping(principalId, updateRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create global rule
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createGlobalRule(rule: Rule, options?: any) {
        return AdminApiFp(this.configuration).createGlobalRule(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
     * @summary Create a new role mapping
     * @param {RoleMapping} roleMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createRoleMapping(roleMapping: RoleMapping, options?: any) {
        return AdminApiFp(this.configuration).createRoleMapping(roleMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Delete all global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAllGlobalRules(options?: any) {
        return AdminApiFp(this.configuration).deleteAllGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Delete global rule
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteGlobalRule(rule: RuleType, options?: any) {
        return AdminApiFp(this.configuration).deleteGlobalRule(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Delete a role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteRoleMapping(principalId: string, options?: any) {
        return AdminApiFp(this.configuration).deleteRoleMapping(principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports registry data as a ZIP archive.
     * @summary Export registry data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportData(options?: any) {
        return AdminApiFp(this.configuration).exportData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getGlobalRuleConfig(rule: RuleType, options?: any) {
        return AdminApiFp(this.configuration).getGlobalRuleConfig(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
     * @summary Get a single logger configuration
     * @param {string} logger The name of a single logger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getLogConfiguration(logger: string, options?: any) {
        return AdminApiFp(this.configuration).getLogConfiguration(logger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Return a single role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getRoleMapping(principalId: string, options?: any) {
        return AdminApiFp(this.configuration).getRoleMapping(principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports registry data that was previously exported using the `/admin/export` operation.
     * @summary Import registry data
     * @param {any} body The ZIP file representing the previously exported registry data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public importData(body: any, options?: any) {
        return AdminApiFp(this.configuration).importData(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listGlobalRules(options?: any) {
        return AdminApiFp(this.configuration).listGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the configured logging levels.  These override the default logging configuration.
     * @summary List logging configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listLogConfigurations(options?: any) {
        return AdminApiFp(this.configuration).listLogConfigurations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List all role mappings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listRoleMappings(options?: any) {
        return AdminApiFp(this.configuration).listRoleMappings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the configured logger configuration (if any) for the given logger.
     * @summary Removes logger configuration
     * @param {string} logger The name of a single logger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public removeLogConfiguration(logger: string, options?: any) {
        return AdminApiFp(this.configuration).removeLogConfiguration(logger, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configures the logger referenced by the provided logger name with the given configuration.
     * @summary Set a logger\'s configuration
     * @param {string} logger The name of a single logger.
     * @param {LogConfiguration} logConfiguration The new logger configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setLogConfiguration(logger: string, logConfiguration: LogConfiguration, options?: any) {
        return AdminApiFp(this.configuration).setLogConfiguration(logger, logConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {Rule} rule2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: any) {
        return AdminApiFp(this.configuration).updateGlobalRuleConfig(rule, rule2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update a role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {UpdateRole} updateRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: any) {
        return AdminApiFp(this.configuration).updateRoleMapping(principalId, updateRole, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactRulesApi - axios parameter creator
 * @export
 */
export const ArtifactRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactRule: async (groupId: string, artifactId: string, rule: Rule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifactRule', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createArtifactRule', 'artifactId', artifactId)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('createArtifactRule', 'rule', rule)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRule: async (groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactRule', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactRule', 'artifactId', artifactId)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('deleteArtifactRule', 'rule', rule)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{rule}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRules: async (groupId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactRules', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactRules', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactRuleConfig: async (groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'artifactId', artifactId)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'rule', rule)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{rule}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, the set of globally configured rules are used.  If no global rules  are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactRules: async (groupId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactRules', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listArtifactRules', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests whether an update to the artifact\'s content *would* succeed for the provided content. Ultimately, this applies any rules configured for the artifact against the given content to determine whether the rules would pass or fail, but without actually updating the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in  JSON format for *most* of the supported types, but may be in another format for a few  (for example, `PROTOBUF`).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * The provided artifact type is not recognized (HTTP error `404`) * A server error occurred (HTTP error `500`)  When successful, this operation simply returns a *No Content* response.  This response indicates that the content is valid against the configured content rules for the  artifact (or the global rules if no artifact rules are enabled).
         * @summary Test update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact being tested. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpdateArtifact: async (groupId: string, artifactId: string, body: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('testUpdateArtifact', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('testUpdateArtifact', 'artifactId', artifactId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('testUpdateArtifact', 'body', body)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/test`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactRuleConfig: async (groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', rule2: Rule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'artifactId', artifactId)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'rule', rule)
            // verify required parameter 'rule2' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'rule2', rule2)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{rule}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactRulesApi - functional programming interface
 * @export
 */
export const ArtifactRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifactRule(groupId: string, artifactId: string, rule: Rule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifactRule(groupId, artifactId, rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactRule(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactRule(groupId, artifactId, rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactRules(groupId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactRules(groupId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactRuleConfig(groupId, artifactId, rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, the set of globally configured rules are used.  If no global rules  are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactRules(groupId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactRules(groupId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests whether an update to the artifact\'s content *would* succeed for the provided content. Ultimately, this applies any rules configured for the artifact against the given content to determine whether the rules would pass or fail, but without actually updating the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in  JSON format for *most* of the supported types, but may be in another format for a few  (for example, `PROTOBUF`).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * The provided artifact type is not recognized (HTTP error `404`) * A server error occurred (HTTP error `500`)  When successful, this operation simply returns a *No Content* response.  This response indicates that the content is valid against the configured content rules for the  artifact (or the global rules if no artifact rules are enabled).
         * @summary Test update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact being tested. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testUpdateArtifact(groupId: string, artifactId: string, body: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testUpdateArtifact(groupId, artifactId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', rule2: Rule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactRuleConfig(groupId, artifactId, rule, rule2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactRulesApi - factory interface
 * @export
 */
export const ArtifactRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactRulesApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactRule(groupId: string, artifactId: string, rule: Rule, options?: any): AxiosPromise<void> {
            return localVarFp.createArtifactRule(groupId, artifactId, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRule(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactRule(groupId, artifactId, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRules(groupId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactRules(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any): AxiosPromise<Rule> {
            return localVarFp.getArtifactRuleConfig(groupId, artifactId, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, the set of globally configured rules are used.  If no global rules  are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactRules(groupId: string, artifactId: string, options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listArtifactRules(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests whether an update to the artifact\'s content *would* succeed for the provided content. Ultimately, this applies any rules configured for the artifact against the given content to determine whether the rules would pass or fail, but without actually updating the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in  JSON format for *most* of the supported types, but may be in another format for a few  (for example, `PROTOBUF`).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * The provided artifact type is not recognized (HTTP error `404`) * A server error occurred (HTTP error `500`)  When successful, this operation simply returns a *No Content* response.  This response indicates that the content is valid against the configured content rules for the  artifact (or the global rules if no artifact rules are enabled).
         * @summary Test update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact being tested. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpdateArtifact(groupId: string, artifactId: string, body: any, options?: any): AxiosPromise<void> {
            return localVarFp.testUpdateArtifact(groupId, artifactId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', rule2: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateArtifactRuleConfig(groupId, artifactId, rule, rule2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactRulesApi - object-oriented interface
 * @export
 * @class ArtifactRulesApi
 * @extends {BaseAPI}
 */
export class ArtifactRulesApi extends BaseAPI {
    /**
     * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Create artifact rule
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public createArtifactRule(groupId: string, artifactId: string, rule: Rule, options?: any) {
        return ArtifactRulesApiFp(this.configuration).createArtifactRule(groupId, artifactId, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact rule
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public deleteArtifactRule(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any) {
        return ArtifactRulesApiFp(this.configuration).deleteArtifactRule(groupId, artifactId, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact rules
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public deleteArtifactRules(groupId: string, artifactId: string, options?: any) {
        return ArtifactRulesApiFp(this.configuration).deleteArtifactRules(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Get artifact rule configuration
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public getArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', options?: any) {
        return ArtifactRulesApiFp(this.configuration).getArtifactRuleConfig(groupId, artifactId, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, the set of globally configured rules are used.  If no global rules  are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary List artifact rules
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public listArtifactRules(groupId: string, artifactId: string, options?: any) {
        return ArtifactRulesApiFp(this.configuration).listArtifactRules(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests whether an update to the artifact\'s content *would* succeed for the provided content. Ultimately, this applies any rules configured for the artifact against the given content to determine whether the rules would pass or fail, but without actually updating the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in  JSON format for *most* of the supported types, but may be in another format for a few  (for example, `PROTOBUF`).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * The provided artifact type is not recognized (HTTP error `404`) * A server error occurred (HTTP error `500`)  When successful, this operation simply returns a *No Content* response.  This response indicates that the content is valid against the configured content rules for the  artifact (or the global rules if no artifact rules are enabled).
     * @summary Test update artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {any} body The content of the artifact being tested. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public testUpdateArtifact(groupId: string, artifactId: string, body: any, options?: any) {
        return ArtifactRulesApiFp(this.configuration).testUpdateArtifact(groupId, artifactId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact rule configuration
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {'VALIDITY' | 'COMPATIBILITY'} rule The unique name/type of a rule.
     * @param {Rule} rule2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public updateArtifactRuleConfig(groupId: string, artifactId: string, rule: 'VALIDITY' | 'COMPATIBILITY', rule2: Rule, options?: any) {
        return ArtifactRulesApiFp(this.configuration).updateArtifactRuleConfig(groupId, artifactId, rule, rule2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, `PROTOBUF`).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`  HTTP request header, or include a hint in the request\'s `Content-Type`.  For example:  ``` Content-Type: application/json; artifactType=AVRO ```  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the `X-Registry-ArtifactId` request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact
         * @param {string} groupId Unique ID of an artifact group.
         * @param {any} body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {ArtifactType} [xRegistryArtifactType] Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)
         * @param {string} [xRegistryArtifactId] A client-provided, globally unique identifier for the new artifact.
         * @param {string} [xRegistryVersion] Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;).
         * @param {IfExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {string} [xRegistryDescription] Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryName] Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (groupId: string, body: any, xRegistryArtifactType?: ArtifactType, xRegistryArtifactId?: string, xRegistryVersion?: string, ifExists?: IfExists, canonical?: boolean, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryName?: string, xRegistryNameEncoded?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifact', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createArtifact', 'body', body)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifExists !== undefined) {
                localVarQueryParameter['ifExists'] = ifExists;
            }

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (xRegistryArtifactType !== undefined && xRegistryArtifactType !== null) {
                localVarHeaderParameter['X-Registry-ArtifactType'] = String(JSON.stringify(xRegistryArtifactType));
            }

            if (xRegistryArtifactId !== undefined && xRegistryArtifactId !== null) {
                localVarHeaderParameter['X-Registry-ArtifactId'] = String(xRegistryArtifactId);
            }

            if (xRegistryVersion !== undefined && xRegistryVersion !== null) {
                localVarHeaderParameter['X-Registry-Version'] = String(xRegistryVersion);
            }

            if (xRegistryDescription !== undefined && xRegistryDescription !== null) {
                localVarHeaderParameter['X-Registry-Description'] = String(xRegistryDescription);
            }

            if (xRegistryDescriptionEncoded !== undefined && xRegistryDescriptionEncoded !== null) {
                localVarHeaderParameter['X-Registry-Description-Encoded'] = String(xRegistryDescriptionEncoded);
            }

            if (xRegistryName !== undefined && xRegistryName !== null) {
                localVarHeaderParameter['X-Registry-Name'] = String(xRegistryName);
            }

            if (xRegistryNameEncoded !== undefined && xRegistryNameEncoded !== null) {
                localVarHeaderParameter['X-Registry-Name-Encoded'] = String(xRegistryNameEncoded);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (groupId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifact', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Deletes all artifacts in a group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsInGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactsInGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByGlobalId: async (globalId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'globalId' is not null or undefined
            assertParamExists('getContentByGlobalId', 'globalId', globalId)
            const localVarPath = `/ids/globalIds/{globalId}`
                .replace(`{${"globalId"}}`, encodeURIComponent(String(globalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByHash: async (contentHash: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentHash' is not null or undefined
            assertParamExists('getContentByHash', 'contentHash', contentHash)
            const localVarPath = `/ids/contentHashes/{contentHash}/`
                .replace(`{${"contentHash"}}`, encodeURIComponent(String(contentHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentById: async (contentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('getContentById', 'contentId', contentId)
            const localVarPath = `/ids/contentIds/{contentId}/`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the response depends on the artifact type.  In most cases, this is `application/json`, but  for some types it may be different (for example, `PROTOBUF`).  This operation may fail for one of the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get latest artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestArtifact: async (groupId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getLatestArtifact', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getLatestArtifact', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsInGroup: async (groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: SortBy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactsInGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria. 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by label.  Include one or more label to only return artifacts containing all of the specified labels.
         * @param {Array<string>} [properties] Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [group] Filter by artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: SortBy, labels?: Array<string>, properties?: Array<string>, description?: string, group?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (properties) {
                localVarQueryParameter['properties'] = properties;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
         * @summary Search for artifacts by content
         * @param {any} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {ArtifactType} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {'asc' | 'desc'} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {'name' | 'createdOn'} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifactsByContent: async (body: any, canonical?: boolean, artifactType?: ArtifactType, offset?: number, limit?: number, order?: 'asc' | 'desc', orderby?: 'name' | 'createdOn', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchArtifactsByContent', 'body', body)
            const localVarPath = `/search/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (artifactType !== undefined) {
                localVarQueryParameter['artifactType'] = artifactType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an artifact by uploading new content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, `PROTOBUF`). The type of the content should be compatible with the artifact\'s type (it would be an error to update an `AVRO` artifact with new `OPENAPI` content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
         * @summary Update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryNameEncoded?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifact', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifact', 'artifactId', artifactId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateArtifact', 'body', body)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRegistryVersion !== undefined && xRegistryVersion !== null) {
                localVarHeaderParameter['X-Registry-Version'] = String(xRegistryVersion);
            }

            if (xRegistryName !== undefined && xRegistryName !== null) {
                localVarHeaderParameter['X-Registry-Name'] = String(xRegistryName);
            }

            if (xRegistryNameEncoded !== undefined && xRegistryNameEncoded !== null) {
                localVarHeaderParameter['X-Registry-Name-Encoded'] = String(xRegistryNameEncoded);
            }

            if (xRegistryDescription !== undefined && xRegistryDescription !== null) {
                localVarHeaderParameter['X-Registry-Description'] = String(xRegistryDescription);
            }

            if (xRegistryDescriptionEncoded !== undefined && xRegistryDescriptionEncoded !== null) {
                localVarHeaderParameter['X-Registry-Description-Encoded'] = String(xRegistryDescriptionEncoded);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as `DEPRECATED`.  The operation changes the state of the latest  version of the artifact.  If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactState: async (groupId: string, artifactId: string, updateState: UpdateState, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactState', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactState', 'artifactId', artifactId)
            // verify required parameter 'updateState' is not null or undefined
            assertParamExists('updateArtifactState', 'updateState', updateState)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/state`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, `PROTOBUF`).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`  HTTP request header, or include a hint in the request\'s `Content-Type`.  For example:  ``` Content-Type: application/json; artifactType=AVRO ```  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the `X-Registry-ArtifactId` request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact
         * @param {string} groupId Unique ID of an artifact group.
         * @param {any} body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {ArtifactType} [xRegistryArtifactType] Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)
         * @param {string} [xRegistryArtifactId] A client-provided, globally unique identifier for the new artifact.
         * @param {string} [xRegistryVersion] Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;).
         * @param {IfExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {string} [xRegistryDescription] Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryName] Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(groupId: string, body: any, xRegistryArtifactType?: ArtifactType, xRegistryArtifactId?: string, xRegistryVersion?: string, ifExists?: IfExists, canonical?: boolean, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryName?: string, xRegistryNameEncoded?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(groupId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(groupId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Deletes all artifacts in a group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactsInGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactsInGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentByGlobalId(globalId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentByGlobalId(globalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentByHash(contentHash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentByHash(contentHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentById(contentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentById(contentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the response depends on the artifact type.  In most cases, this is `application/json`, but  for some types it may be different (for example, `PROTOBUF`).  This operation may fail for one of the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get latest artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestArtifact(groupId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestArtifact(groupId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: SortBy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactsInGroup(groupId, limit, offset, order, orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria. 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by label.  Include one or more label to only return artifacts containing all of the specified labels.
         * @param {Array<string>} [properties] Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [group] Filter by artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: SortBy, labels?: Array<string>, properties?: Array<string>, description?: string, group?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(name, offset, limit, order, orderby, labels, properties, description, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
         * @summary Search for artifacts by content
         * @param {any} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {ArtifactType} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {'asc' | 'desc'} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {'name' | 'createdOn'} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifactsByContent(body: any, canonical?: boolean, artifactType?: ArtifactType, offset?: number, limit?: number, order?: 'asc' | 'desc', orderby?: 'name' | 'createdOn', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifactsByContent(body, canonical, artifactType, offset, limit, order, orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an artifact by uploading new content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, `PROTOBUF`). The type of the content should be compatible with the artifact\'s type (it would be an error to update an `AVRO` artifact with new `OPENAPI` content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
         * @summary Update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryNameEncoded?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifact(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as `DEPRECATED`.  The operation changes the state of the latest  version of the artifact.  If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactState(groupId: string, artifactId: string, updateState: UpdateState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactState(groupId, artifactId, updateState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, `PROTOBUF`).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`  HTTP request header, or include a hint in the request\'s `Content-Type`.  For example:  ``` Content-Type: application/json; artifactType=AVRO ```  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the `X-Registry-ArtifactId` request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact
         * @param {string} groupId Unique ID of an artifact group.
         * @param {any} body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {ArtifactType} [xRegistryArtifactType] Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)
         * @param {string} [xRegistryArtifactId] A client-provided, globally unique identifier for the new artifact.
         * @param {string} [xRegistryVersion] Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;).
         * @param {IfExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {string} [xRegistryDescription] Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryName] Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(groupId: string, body: any, xRegistryArtifactType?: ArtifactType, xRegistryArtifactId?: string, xRegistryVersion?: string, ifExists?: IfExists, canonical?: boolean, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryName?: string, xRegistryNameEncoded?: string, options?: any): AxiosPromise<ArtifactMetaData> {
            return localVarFp.createArtifact(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(groupId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Deletes all artifacts in a group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsInGroup(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactsInGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByGlobalId(globalId: number, options?: any): AxiosPromise<any> {
            return localVarFp.getContentByGlobalId(globalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByHash(contentHash: string, options?: any): AxiosPromise<any> {
            return localVarFp.getContentByHash(contentHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentById(contentId: number, options?: any): AxiosPromise<any> {
            return localVarFp.getContentById(contentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the response depends on the artifact type.  In most cases, this is `application/json`, but  for some types it may be different (for example, `PROTOBUF`).  This operation may fail for one of the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get latest artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestArtifact(groupId: string, artifactId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getLatestArtifact(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId Unique ID of an artifact group.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: SortBy, options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.listArtifactsInGroup(groupId, limit, offset, order, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria. 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by label.  Include one or more label to only return artifacts containing all of the specified labels.
         * @param {Array<string>} [properties] Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [group] Filter by artifact group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: SortBy, labels?: Array<string>, properties?: Array<string>, description?: string, group?: string, options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.searchArtifacts(name, offset, limit, order, orderby, labels, properties, description, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
         * @summary Search for artifacts by content
         * @param {any} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {ArtifactType} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {'asc' | 'desc'} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {'name' | 'createdOn'} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifactsByContent(body: any, canonical?: boolean, artifactType?: ArtifactType, offset?: number, limit?: number, order?: 'asc' | 'desc', orderby?: 'name' | 'createdOn', options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.searchArtifactsByContent(body, canonical, artifactType, offset, limit, order, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an artifact by uploading new content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, `PROTOBUF`). The type of the content should be compatible with the artifact\'s type (it would be an error to update an `AVRO` artifact with new `OPENAPI` content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
         * @summary Update artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryNameEncoded?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, options?: any): AxiosPromise<ArtifactMetaData> {
            return localVarFp.updateArtifact(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as `DEPRECATED`.  The operation changes the state of the latest  version of the artifact.  If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactState(groupId: string, artifactId: string, updateState: UpdateState, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactState(groupId, artifactId, updateState, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, `PROTOBUF`).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType`  HTTP request header, or include a hint in the request\'s `Content-Type`.  For example:  ``` Content-Type: application/json; artifactType=AVRO ```  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the `X-Registry-ArtifactId` request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create artifact
     * @param {string} groupId Unique ID of an artifact group.
     * @param {any} body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
     * @param {ArtifactType} [xRegistryArtifactType] Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)
     * @param {string} [xRegistryArtifactId] A client-provided, globally unique identifier for the new artifact.
     * @param {string} [xRegistryVersion] Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;).
     * @param {IfExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
     * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
     * @param {string} [xRegistryDescription] Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
     * @param {string} [xRegistryDescriptionEncoded] Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
     * @param {string} [xRegistryName] Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
     * @param {string} [xRegistryNameEncoded] Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public createArtifact(groupId: string, body: any, xRegistryArtifactType?: ArtifactType, xRegistryArtifactId?: string, xRegistryVersion?: string, ifExists?: IfExists, canonical?: boolean, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryName?: string, xRegistryNameEncoded?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).createArtifact(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifact(groupId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).deleteArtifact(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all of the artifacts that exist in a given group.
     * @summary Deletes all artifacts in a group
     * @param {string} groupId Unique ID of an artifact group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifactsInGroup(groupId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).deleteArtifactsInGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact by global ID
     * @param {number} globalId Global identifier for an artifact version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentByGlobalId(globalId: number, options?: any) {
        return ArtifactsApiFp(this.configuration).getContentByGlobalId(globalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact content by SHA-256 hash
     * @param {string} contentHash SHA-256 content hash for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentByHash(contentHash: string, options?: any) {
        return ArtifactsApiFp(this.configuration).getContentByHash(contentHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact content by ID
     * @param {number} contentId Global identifier for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentById(contentId: number, options?: any) {
        return ArtifactsApiFp(this.configuration).getContentById(contentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest version of the artifact in its raw form.  The `Content-Type` of the response depends on the artifact type.  In most cases, this is `application/json`, but  for some types it may be different (for example, `PROTOBUF`).  This operation may fail for one of the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get latest artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getLatestArtifact(groupId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).getLatestArtifact(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all artifacts in the group.  This list is paged.
     * @summary List artifacts in group
     * @param {string} groupId Unique ID of an artifact group.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: SortBy, options?: any) {
        return ArtifactsApiFp(this.configuration).listArtifactsInGroup(groupId, limit, offset, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all artifacts that match the provided filter criteria. 
     * @summary Search for artifacts
     * @param {string} [name] Filter by artifact name.
     * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {SortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {Array<string>} [labels] Filter by label.  Include one or more label to only return artifacts containing all of the specified labels.
     * @param {Array<string>} [properties] Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;.
     * @param {string} [description] Filter by description.
     * @param {string} [group] Filter by artifact group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: SortBy, labels?: Array<string>, properties?: Array<string>, description?: string, group?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).searchArtifacts(name, offset, limit, order, orderby, labels, properties, description, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
     * @summary Search for artifacts by content
     * @param {any} body The content to search for.
     * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
     * @param {ArtifactType} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
     * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {'asc' | 'desc'} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {'name' | 'createdOn'} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public searchArtifactsByContent(body: any, canonical?: boolean, artifactType?: ArtifactType, offset?: number, limit?: number, order?: 'asc' | 'desc', orderby?: 'name' | 'createdOn', options?: any) {
        return ArtifactsApiFp(this.configuration).searchArtifactsByContent(body, canonical, artifactType, offset, limit, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an artifact by uploading new content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, `PROTOBUF`). The type of the content should be compatible with the artifact\'s type (it would be an error to update an `AVRO` artifact with new `OPENAPI` content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
     * @summary Update artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {any} body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
     * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically.
     * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
     * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
     * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
     * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public updateArtifact(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryNameEncoded?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, options?: any) {
        return ArtifactsApiFp(this.configuration).updateArtifact(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as `DEPRECATED`.  The operation changes the state of the latest  version of the artifact.  If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact state
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {UpdateState} updateState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public updateArtifactState(groupId: string, artifactId: string, updateState: UpdateState, options?: any) {
        return ArtifactsApiFp(this.configuration).updateArtifactState(groupId, artifactId, updateState, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersionMetaData: async (groupId: string, artifactId: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactVersionMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactVersionMetaData', 'artifactId', artifactId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteArtifactVersionMetaData', 'version', version)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactMetaData: async (groupId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactMetaData', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaData: async (groupId: string, artifactId: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'artifactId', artifactId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'version', version)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata by content
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of an artifact version.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaDataByContent: async (groupId: string, artifactId: string, body: any, canonical?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionMetaDataByContent', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionMetaDataByContent', 'artifactId', artifactId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getArtifactVersionMetaDataByContent', 'body', body)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {EditableMetaData} editableMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactMetaData: async (groupId: string, artifactId: string, editableMetaData: EditableMetaData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'artifactId', artifactId)
            // verify required parameter 'editableMetaData' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'editableMetaData', editableMetaData)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {EditableMetaData} editableMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionMetaData: async (groupId: string, artifactId: string, version: string, editableMetaData: EditableMetaData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'artifactId', artifactId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'version', version)
            // verify required parameter 'editableMetaData' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'editableMetaData', editableMetaData)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactVersionMetaData(groupId, artifactId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactMetaData(groupId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactMetaData(groupId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionMetaData(groupId, artifactId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata by content
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of an artifact version.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionMetaDataByContent(groupId: string, artifactId: string, body: any, canonical?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionMetaDataByContent(groupId, artifactId, body, canonical, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {EditableMetaData} editableMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactMetaData(groupId: string, artifactId: string, editableMetaData: EditableMetaData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactMetaData(groupId, artifactId, editableMetaData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {EditableMetaData} editableMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactVersionMetaData(groupId: string, artifactId: string, version: string, editableMetaData: EditableMetaData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactVersionMetaData(groupId, artifactId, version, editableMetaData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactVersionMetaData(groupId, artifactId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactMetaData(groupId: string, artifactId: string, options?: any): AxiosPromise<ArtifactMetaData> {
            return localVarFp.getArtifactMetaData(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any): AxiosPromise<VersionMetaData> {
            return localVarFp.getArtifactVersionMetaData(groupId, artifactId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata by content
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of an artifact version.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaDataByContent(groupId: string, artifactId: string, body: any, canonical?: boolean, options?: any): AxiosPromise<VersionMetaData> {
            return localVarFp.getArtifactVersionMetaDataByContent(groupId, artifactId, body, canonical, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {EditableMetaData} editableMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactMetaData(groupId: string, artifactId: string, editableMetaData: EditableMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactMetaData(groupId, artifactId, editableMetaData, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {EditableMetaData} editableMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionMetaData(groupId: string, artifactId: string, version: string, editableMetaData: EditableMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactVersionMetaData(groupId, artifactId, version, editableMetaData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Delete artifact version metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {string} version The unique identifier of a specific version of the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public deleteArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any) {
        return MetadataApiFp(this.configuration).deleteArtifactVersionMetaData(groupId, artifactId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Get artifact metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getArtifactMetaData(groupId: string, artifactId: string, options?: any) {
        return MetadataApiFp(this.configuration).getArtifactMetaData(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {string} version The unique identifier of a specific version of the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getArtifactVersionMetaData(groupId: string, artifactId: string, version: string, options?: any) {
        return MetadataApiFp(this.configuration).getArtifactVersionMetaData(groupId, artifactId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version metadata by content
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {any} body The content of an artifact version.
     * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getArtifactVersionMetaDataByContent(groupId: string, artifactId: string, body: any, canonical?: boolean, options?: any) {
        return MetadataApiFp(this.configuration).getArtifactVersionMetaDataByContent(groupId, artifactId, body, canonical, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Update artifact metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {EditableMetaData} editableMetaData Updated artifact metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public updateArtifactMetaData(groupId: string, artifactId: string, editableMetaData: EditableMetaData, options?: any) {
        return MetadataApiFp(this.configuration).updateArtifactMetaData(groupId, artifactId, editableMetaData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact version metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {string} version The unique identifier of a specific version of the artifact content.
     * @param {EditableMetaData} editableMetaData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public updateArtifactVersionMetaData(groupId: string, artifactId: string, version: string, editableMetaData: EditableMetaData, options?: any) {
        return MetadataApiFp(this.configuration).updateArtifactVersionMetaData(groupId, artifactId, version, editableMetaData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.getSystemInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
     * @summary Get system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getCurrentUserInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Returns information about the currently authenticated user.
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserInfo(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request should be the raw content of the new artifact version, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact version being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  It must be unique within the artifact.  If this is not provided, the server will generate a new, unique version number for this new updated content.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactVersion: async (groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryNameEncoded?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifactVersion', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createArtifactVersion', 'artifactId', artifactId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createArtifactVersion', 'body', body)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRegistryVersion !== undefined && xRegistryVersion !== null) {
                localVarHeaderParameter['X-Registry-Version'] = String(xRegistryVersion);
            }

            if (xRegistryName !== undefined && xRegistryName !== null) {
                localVarHeaderParameter['X-Registry-Name'] = String(xRegistryName);
            }

            if (xRegistryDescription !== undefined && xRegistryDescription !== null) {
                localVarHeaderParameter['X-Registry-Description'] = String(xRegistryDescription);
            }

            if (xRegistryDescriptionEncoded !== undefined && xRegistryDescriptionEncoded !== null) {
                localVarHeaderParameter['X-Registry-Description-Encoded'] = String(xRegistryDescriptionEncoded);
            }

            if (xRegistryNameEncoded !== undefined && xRegistryNameEncoded !== null) {
                localVarHeaderParameter['X-Registry-Name-Encoded'] = String(xRegistryNameEncoded);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersion: async (groupId: string, artifactId: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersion', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersion', 'artifactId', artifactId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getArtifactVersion', 'version', version)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{version}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactVersions: async (groupId: string, artifactId: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactVersions', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listArtifactVersions', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the state of a specific version of an artifact.  For example, you can use  this operation to disable a specific version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionState: async (groupId: string, artifactId: string, version: string, updateState: UpdateState, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactVersionState', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactVersionState', 'artifactId', artifactId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('updateArtifactVersionState', 'version', version)
            // verify required parameter 'updateState' is not null or undefined
            assertParamExists('updateArtifactVersionState', 'updateState', updateState)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/state`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request should be the raw content of the new artifact version, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact version being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  It must be unique within the artifact.  If this is not provided, the server will generate a new, unique version number for this new updated content.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifactVersion(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryNameEncoded?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifactVersion(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryNameEncoded, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersion(groupId: string, artifactId: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersion(groupId, artifactId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactVersions(groupId, artifactId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the state of a specific version of an artifact.  For example, you can use  this operation to disable a specific version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactVersionState(groupId: string, artifactId: string, version: string, updateState: UpdateState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactVersionState(groupId, artifactId, version, updateState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request should be the raw content of the new artifact version, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {any} body The content of the artifact version being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
         * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  It must be unique within the artifact.  If this is not provided, the server will generate a new, unique version number for this new updated content.
         * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
         * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
         * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactVersion(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryNameEncoded?: string, options?: any): AxiosPromise<VersionMetaData> {
            return localVarFp.createArtifactVersion(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryNameEncoded, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersion(groupId: string, artifactId: string, version: string, options?: any): AxiosPromise<any> {
            return localVarFp.getArtifactVersion(groupId, artifactId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, options?: any): AxiosPromise<VersionSearchResults> {
            return localVarFp.listArtifactVersions(groupId, artifactId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the state of a specific version of an artifact.  For example, you can use  this operation to disable a specific version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version state
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
         * @param {string} version The unique identifier of a specific version of the artifact content.
         * @param {UpdateState} updateState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionState(groupId: string, artifactId: string, version: string, updateState: UpdateState, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactVersionState(groupId, artifactId, version, updateState, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request should be the raw content of the new artifact version, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create artifact version
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {any} body The content of the artifact version being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) 
     * @param {string} [xRegistryVersion] Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  It must be unique within the artifact.  If this is not provided, the server will generate a new, unique version number for this new updated content.
     * @param {string} [xRegistryName] Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content.
     * @param {string} [xRegistryDescription] Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content.
     * @param {string} [xRegistryDescriptionEncoded] Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content.
     * @param {string} [xRegistryNameEncoded] Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public createArtifactVersion(groupId: string, artifactId: string, body: any, xRegistryVersion?: string, xRegistryName?: string, xRegistryDescription?: string, xRegistryDescriptionEncoded?: string, xRegistryNameEncoded?: string, options?: any) {
        return VersionsApiFp(this.configuration).createArtifactVersion(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryNameEncoded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {string} version The unique identifier of a specific version of the artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getArtifactVersion(groupId: string, artifactId: string, version: string, options?: any) {
        return VersionsApiFp(this.configuration).getArtifactVersion(groupId, artifactId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary List artifact versions
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of versions to return.  Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, options?: any) {
        return VersionsApiFp(this.configuration).listArtifactVersions(groupId, artifactId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the state of a specific version of an artifact.  For example, you can use  this operation to disable a specific version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact version state
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
     * @param {string} version The unique identifier of a specific version of the artifact content.
     * @param {UpdateState} updateState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public updateArtifactVersionState(groupId: string, artifactId: string, version: string, updateState: UpdateState, options?: any) {
        return VersionsApiFp(this.configuration).updateArtifactVersionState(groupId, artifactId, version, updateState, options).then((request) => request(this.axios, this.basePath));
    }
}


