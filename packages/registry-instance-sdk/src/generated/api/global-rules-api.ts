/* tslint:disable */
/* eslint-disable */
/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.2.5.Final
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Rule } from '../model';
// @ts-ignore
import { RuleType } from '../model';
/**
 * GlobalRulesApi - axios parameter creator
 * @export
 */
export const GlobalRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule: async (rule: Rule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('createGlobalRule', 'rule', rule)
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule: async (rule: RuleType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('deleteGlobalRule', 'rule', rule)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig: async (rule: RuleType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('getGlobalRuleConfig', 'rule', rule)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig: async (rule: RuleType, rule2: Rule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'rule', rule)
            // verify required parameter 'rule2' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'rule2', rule2)
            const localVarPath = `/admin/rules/{rule}`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalRulesApi - functional programming interface
 * @export
 */
export const GlobalRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlobalRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGlobalRule(rule: Rule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGlobalRule(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllGlobalRules(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllGlobalRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGlobalRule(rule: RuleType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGlobalRule(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalRuleConfig(rule: RuleType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalRuleConfig(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGlobalRules(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGlobalRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalRuleConfig(rule, rule2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GlobalRulesApi - factory interface
 * @export
 */
export const GlobalRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlobalRulesApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule(rule: Rule, options?: any): AxiosPromise<void> {
            return localVarFp.createGlobalRule(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules(options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule(rule: RuleType, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGlobalRule(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig(rule: RuleType, options?: any): AxiosPromise<Rule> {
            return localVarFp.getGlobalRuleConfig(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules(options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} rule The unique name/type of a rule.
         * @param {Rule} rule2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateGlobalRuleConfig(rule, rule2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlobalRulesApi - interface
 * @export
 * @interface GlobalRulesApi
 */
export interface GlobalRulesApiInterface {
    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create global rule
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    createGlobalRule(rule: Rule, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Delete all global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    deleteAllGlobalRules(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Delete global rule
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    deleteGlobalRule(rule: RuleType, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    getGlobalRuleConfig(rule: RuleType, options?: AxiosRequestConfig): AxiosPromise<Rule>;

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    listGlobalRules(options?: AxiosRequestConfig): AxiosPromise<Array<RuleType>>;

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {Rule} rule2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApiInterface
     */
    updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: AxiosRequestConfig): AxiosPromise<Rule>;

}

/**
 * GlobalRulesApi - object-oriented interface
 * @export
 * @class GlobalRulesApi
 * @extends {BaseAPI}
 */
export class GlobalRulesApi extends BaseAPI implements GlobalRulesApiInterface {
    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create global rule
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public createGlobalRule(rule: Rule, options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).createGlobalRule(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Delete all global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public deleteAllGlobalRules(options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).deleteAllGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Delete global rule
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public deleteGlobalRule(rule: RuleType, options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).deleteGlobalRule(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public getGlobalRuleConfig(rule: RuleType, options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).getGlobalRuleConfig(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public listGlobalRules(options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).listGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update global rule configuration
     * @param {RuleType} rule The unique name/type of a rule.
     * @param {Rule} rule2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRulesApi
     */
    public updateGlobalRuleConfig(rule: RuleType, rule2: Rule, options?: AxiosRequestConfig) {
        return GlobalRulesApiFp(this.configuration).updateGlobalRuleConfig(rule, rule2, options).then((request) => request(this.axios, this.basePath));
    }
}
